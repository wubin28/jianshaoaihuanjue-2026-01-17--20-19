## Me:

```
我喜欢你的推荐。ENTER PLAN MODE
```

## Claude code with sonnet 4.5:

```

● [MODE: PLAN]

  工作目标

  创建一份 Markdown 格式的 spec-kit 框架工作流程完整解释文档，采用"完整工作流链路图 +
  修改点索引"作为主体，结合"场景驱动调整指南"作为补充，帮助您理解和调整框架行为。

  输出物规格

  主文档：spec-kit-workflow-explanation.md
  - 位置：项目根目录
  - 格式：Markdown，包含 Mermaid 流程图
  - 估计长度：8000-12000 字
  - 章节结构：见下文详细规划

  辅助文件（可选）：
  - spec-kit-quick-reference.md - 快速查找索引
  - 流程图导出为独立文件（如需要）

  文档结构设计

  第一部分：概览与导航（约 1000 字）

  1.1 文档说明
  - 文档用途
  - 目标读者
  - 如何使用本文档
  - 符号和约定说明

  1.2 框架全景图
  - spec-kit 框架的设计哲学
  - 核心概念（命令、脚本、模板、占位符）
  - 目录结构总览（.claude/、.specify/、specs/）
  - 快速导航：按需求类型跳转到对应章节

  1.3 五命令速览表
  | 命令 | 功能 | 输入 | 输出 | 关键脚本 | 主要模板 |
  |------|------|------|------|----------|----------|
  | /speckit.constitution | ... | ... | ... | ... | ... |
  | /speckit.specify | ... | ... | ... | ... | ... |
  | /speckit.plan | ... | ... | ... | ... | ... |
  | /speckit.tasks | ... | ... | ... | ... | ... |
  | /speckit.implement | ... | ... | ... | ... | ... |

  第二部分：完整工作流链路详解（约 5000 字）

  章节 2.1：/speckit.constitution - 项目宪法创建

  2.1.1 命令概述
  - 职责：创建或更新项目开发原则
  - 触发时机：项目初始化或原则调整时
  - 典型使用场景

  2.1.2 执行流程图
  graph TD
      A[用户执行 /speckit.constitution] --> B[读取 .specify/memory/constitution.md 模板]
      B --> C[收集/推导占位符值]
      C --> D[填充模板内容]
      D --> E[同步检查: plan-template, spec-template, tasks-template]
      E --> F[生成 Sync Impact Report]
      F --> G[写回 constitution.md]
      G --> H[输出版本变更和待办事项]

  2.1.3 涉及文件清单
  - 命令定义：.claude/commands/speckit.constitution.md (83 行)
  - 模板文件：.specify/memory/constitution.md (99 行)
  - 影响文件：
    - .specify/templates/plan-template.md (需验证 Constitution Check 对齐)
    - .specify/templates/spec-template.md (需验证约束对齐)
    - .specify/templates/tasks-template.md (需验证任务类型对齐)

  2.1.4 关键占位符
  - [PROJECT_NAME] - 项目名称
  - [CONSTITUTION_VERSION] - 语义化版本号
  - [RATIFICATION_DATE] - 首次通过日期
  - [LAST_AMENDED_DATE] - 最后修订日期
  - [PRINCIPLE_N_NAME] - 各原则名称（可变数量）

  2.1.5 验证机制
  - 无剩余方括号占位符检查
  - 版本号语义验证（MAJOR.MINOR.PATCH 规则）
  - 日期格式检查（ISO 8601: YYYY-MM-DD）
  - 原则可测性验证（避免含糊语言）

  2.1.6 修改调整点
  - 调整原则数量：修改 constitution.md 模板，添加/删除 [PRINCIPLE_N_*] 占位符
  - 自定义质量门：在 Constitution Check 部分添加项目特定规则
  - 扩展同步检查：在命令文件第 43-48 行添加新的模板验证逻辑

  2.1.7 错误处理
  - 缺失关键字段 → 插入 TODO(<FIELD_NAME>): explanation
  - 版本递增逻辑不明 → 提示用户选择 MAJOR/MINOR/PATCH
  - 模板同步失败 → 在 Sync Impact Report 中标记 ⚠ pending

  ---
  章节 2.2：/speckit.specify - 功能规格说明创建

  2.2.1 命令概述
  - 职责：将自然语言特性描述转换为结构化规格说明
  - 输入：用户的特性描述（$ARGUMENTS）
  - 输出：specs/###-short-name/spec.md + 质量验证清单

  2.2.2 执行流程图
  graph TD
      A[用户: /speckit.specify <description>] --> B[生成 short-name]
      B --> C[检查已有分支/目录, 计算下一编号]
      C --> D[执行 create-new-feature.sh]
      D --> E[创建分支 NNN-short-name]
      E --> F[创建目录 specs/NNN-short-name/]
      F --> G[复制 spec-template.md → spec.md]
      G --> H[AI 解析特性描述]
      H --> I{是否有不明确点?}
      I -->|有且<=3个| J[标记 NEEDS CLARIFICATION]
      I -->|否| K[填充所有章节]
      J --> K
      K --> L[生成 checklists/requirements.md]
      L --> M[运行质量验证]
      M --> N{验证通过?}
      N -->|是| O[报告就绪, 可进入 plan]
      N -->|否| P[列出失败项 → 修正 spec.md → 重新验证]
      P --> M
      M --> Q{有 NEEDS CLARIFICATION?}
      Q -->|是| R[提取问题 → 展示选项表 → 等待用户回答]
      R --> S[更新 spec.md 移除标记]
      S --> M
      Q -->|否| O

  2.2.3 涉及文件清单
  - 命令定义：.claude/commands/speckit.specify.md (259 行)
  - 脚本：.specify/scripts/bash/create-new-feature.sh (298 行)
  - 模板：.specify/templates/spec-template.md (116 行)
  - 输出目录：specs/###-short-name/
    - spec.md - 主规格说明
    - checklists/requirements.md - 质量验证清单

  2.2.4 关键占位符与变量
  - $ARGUMENTS - 用户输入的原始特性描述
  - [FEATURE NAME] - 从描述提取的功能名称
  - [###-feature-name] - 自动生成的分支名格式
  - [DATE] - 创建日期
  - [Brief Title] - 用户故事标题
  - [NEEDS CLARIFICATION: question] - 特殊标记（最多 3 个）

  2.2.5 脚本机制详解：create-new-feature.sh

  输入参数：
  - --json - JSON 格式输出
  - --short-name <name> - 自定义短名称（可选）
  - --number N - 手动指定编号（可选）
  - <feature_description> - 特性描述（位置参数）

  执行逻辑：
  1. 编号计算（第 129-150 行）
    - 从 Git 分支（本地+远程）提取最高编号
    - 从 specs/ 目录提取最高编号
    - 取两者最大值 +1
  2. 短名称生成（第 180-226 行）
    - 过滤停用词（the, a, to 等）
    - 保留长度 >=3 的有意义词汇
    - 保留全大写缩写（如 API, UI）
    - 取前 3-4 个词，连字符连接
  3. 分支创建（第 274-278 行）
    - 格式：NNN-short-name（NNN 为三位数编号）
    - 如果非 Git 仓库，跳过分支创建但仍创建目录
  4. JSON 输出（第 290-297 行）
  {
    "BRANCH_NAME": "003-user-auth",
    "SPEC_FILE": "/path/to/specs/003-user-auth/spec.md",
    "FEATURE_NUM": "003"
  }

  2.2.6 验证机制：质量清单检查

  清单文件结构（commands 文件 103-140 行定义）：
  # Specification Quality Checklist: [FEATURE NAME]

  ## Content Quality
  - [ ] No implementation details (languages, frameworks, APIs)
  - [ ] Focused on user value and business needs
  - [ ] Written for non-technical stakeholders
  - [ ] All mandatory sections completed

  ## Requirement Completeness
  - [ ] No [NEEDS CLARIFICATION] markers remain
  - [ ] Requirements are testable and unambiguous
  - [ ] Success criteria are measurable
  - [ ] Success criteria are technology-agnostic
  ...

  验证流程（commands 文件 141-192 行）：
  1. 创建清单文件
  2. 逐项检查 spec.md 内容
  3. 如果失败（排除 NEEDS CLARIFICATION）：
    - 列出具体问题
    - 自动修正 spec.md
    - 重新验证（最多 3 次迭代）
  4. 如果有 NEEDS CLARIFICATION：
    - 提取所有标记（最多 3 个）
    - 生成选项表格询问用户
    - 等待回答后替换标记
    - 重新验证

  2.2.7 修改调整点

  调整点 A：修改规格说明结构
  - 文件：.specify/templates/spec-template.md
  - 操作：添加/删除/修改章节
  - 影响：需同步更新质量清单（commands 文件 103-140 行）

  调整点 B：自定义短名称生成规则
  - 文件：.specify/scripts/bash/create-new-feature.sh
  - 函数：generate_branch_name() (180-226 行)
  - 可调整：停用词列表（185 行）、最小词长（198 行）、最大词数（209-210 行）

  调整点 C：调整 NEEDS CLARIFICATION 限制
  - 文件：.claude/commands/speckit.specify.md
  - 位置：第 85 行（**LIMIT: Maximum 3 [NEEDS CLARIFICATION] markers total**）
  - 修改影响：158 行的提取逻辑

  调整点 D：为特定项目类型添加专属模板
  - 方法：复制 spec-template.md 为 spec-template-frontend.md
  - 在 commands 文件第 100 行添加项目类型检测逻辑
  - 根据检测结果选择对应模板

  2.2.8 错误处理

  错误场景 1：特性描述为空
  - 触发位置：commands 文件第 76 行
  - 错误信息：ERROR "No feature description provided"
  - 处理：命令终止，提示用户提供描述

  错误场景 2：无法确定用户场景
  - 触发位置：commands 文件第 88 行
  - 错误信息：ERROR "Cannot determine user scenarios"
  - 处理：命令终止，需用户提供更详细描述

  错误场景 3：验证失败 3 次仍未通过
  - 触发位置：commands 文件第 154 行
  - 处理：文档剩余问题到清单 notes，警告用户
  - 用户后续操作：手动修正或使用 /speckit.clarify

  错误场景 4：分支名超过 GitHub 限制（244 字节）
  - 触发位置：create-new-feature.sh 第 256-272 行
  - 处理：自动截断后缀，警告用户
  - 输出示例：
  Warning: Branch name exceeded GitHub's 244-byte limit
  Original: 003-very-long-feature-name-that-exceeds-the-limit (250 bytes)
  Truncated to: 003-very-long-feature-name-that-exceeds-t (244 bytes)

  ---
  章节 2.3：/speckit.plan - 技术实施计划

  2.3.1 命令概述
  - 职责：基于规格说明生成技术设计文档
  - 前提：spec.md 已完成且通过验证
  - 输出：plan.md、research.md、data-model.md、contracts/、quickstart.md、更新 CLAUDE.md

  2.3.2 执行流程图
  graph TD
      A[用户: /speckit.plan <tech constraints>] --> B[执行 setup-plan.sh --json]
      B --> C[获取 FEATURE_SPEC, IMPL_PLAN 路径]
      C --> D[复制 plan-template.md → plan.md]
      D --> E[读取 spec.md + constitution.md]
      E --> F[填充 Technical Context]
      F --> G{有 NEEDS CLARIFICATION?}
      G -->|是| H[Phase 0: 生成研究任务]
      G -->|否| I[Phase 0: 跳过]
      H --> J[执行研究代理 → research.md]
      J --> K[用研究结果填充 Technical Context]
      K --> L[运行 Constitution Check]
      L --> M{通过质量门?}
      M -->|否| N[ERROR: 列出违规项要求说明]
      M -->|是| O[Phase 1: 提取实体 → data-model.md]
      O --> P[Phase 1: 生成 API 合约 → contracts/]
      P --> Q[Phase 1: 生成 quickstart.md]
      Q --> R[执行 update-agent-context.sh claude]
      R --> S[更新 CLAUDE.md: Active Technologies, Recent Changes]
      S --> T[报告完成: 输出文件路径列表]

  2.3.3 涉及文件清单
  - 命令定义：.claude/commands/speckit.plan.md (90 行)
  - 脚本：
    - .specify/scripts/bash/setup-plan.sh (62 行)
    - .specify/scripts/bash/update-agent-context.sh (800 行)
  - 模板：.specify/templates/plan-template.md (105 行)
  - 输入：
    - specs/###-short-name/spec.md
    - .specify/memory/constitution.md
  - 输出：
    - specs/###-short-name/plan.md - 主计划文档
    - specs/###-short-name/research.md - 技术研究（如有 NEEDS CLARIFICATION）
    - specs/###-short-name/data-model.md - 数据模型
    - specs/###-short-name/contracts/ - API 合约
    - specs/###-short-name/quickstart.md - 快速入门
    - CLAUDE.md - 代理上下文（根目录）

  2.3.4 关键占位符
  - [FEATURE] - 功能名称
  - [###-feature-name] - 分支名
  - [DATE] - 日期
  - [link] - spec.md 的相对路径
  - Technical Context 部分：
    - [e.g., Python 3.11... or NEEDS CLARIFICATION] - 语言版本
    - [e.g., FastAPI... or NEEDS CLARIFICATION] - 主要依赖
    - [if applicable... or N/A] - 存储方案
    - [e.g., pytest... or NEEDS CLARIFICATION] - 测试框架
    - 其他 6 个技术字段

  2.3.5 脚本机制详解：setup-plan.sh

  功能（第 27-60 行）：
  1. 加载 common.sh 获取通用函数
  2. 调用 get_feature_paths() 获取所有路径变量
  3. 检查分支有效性 check_feature_branch()
  4. 确保特性目录存在 mkdir -p "$FEATURE_DIR"
  5. 复制模板 cp plan-template.md $IMPL_PLAN

  JSON 输出格式（第 52-54 行）：
  {
    "FEATURE_SPEC": "/path/to/specs/003-user-auth/spec.md",
    "IMPL_PLAN": "/path/to/specs/003-user-auth/plan.md",
    "SPECS_DIR": "/path/to/specs/003-user-auth",
    "BRANCH": "003-user-auth",
    "HAS_GIT": "true"
  }

  2.3.6 脚本机制详解：update-agent-context.sh

  核心功能（第 7-39 行注释总结）：
  1. 环境验证 - 检查 Git 仓库、分支、plan.md 存在性
  2. 计划数据提取 - 解析 plan.md 的 Technical Context 字段
  3. 代理文件管理 - 创建或更新 CLAUDE.md 等代理文件
  4. 内容生成 - 生成特定语言的命令和项目结构
  5. 多代理支持 - 支持 15+ 种 AI 代理格式

  数据提取函数（第 156-206 行）：
  extract_plan_field() {
      # 从 plan.md 提取 **Field**: value 格式的字段
      grep "^\*\*${field_pattern}\*\*: " "$plan_file" |
          head -1 |
          sed "s|^\*\*${field_pattern}\*\*: ||" |
          grep -v "NEEDS CLARIFICATION" |
          grep -v "^N/A$"
  }

  parse_plan_data() {
      NEW_LANG=$(extract_plan_field "Language/Version" "$plan_file")
      NEW_FRAMEWORK=$(extract_plan_field "Primary Dependencies" "$plan_file")
      NEW_DB=$(extract_plan_field "Storage" "$plan_file")
      NEW_PROJECT_TYPE=$(extract_plan_field "Project Type" "$plan_file")
  }

  代理文件更新逻辑（第 363-502 行）：

  更新已有文件：
  1. 查找 ## Active Technologies 部分
  2. 如果新技术栈不存在，添加条目：
  - TypeScript 5.x + Next.js 16.1.3 (003-user-auth)
  3. 查找 ## Recent Changes 部分
  4. 在顶部插入新变更，保留最近 2 条旧记录：
  - 003-user-auth: Added TypeScript 5.x + Next.js 16.1.3
  5. 更新时间戳（匹配正则替换日期）

  创建新文件（第 270-358 行）：
  1. 从 agent-file-template.md 复制
  2. 执行占位符替换（第 332-340 行）：
  s|[PROJECT NAME]|project-name|
  s|[DATE]|2026-01-19|
  s|[EXTRACTED FROM ALL PLAN.MD FILES]|- TypeScript 5.x + Next.js (003-user-auth)|
  s|[ACTUAL STRUCTURE FROM PLANS]|src/\ntests/|g
  s|[ONLY COMMANDS FOR ACTIVE TECHNOLOGIES]|npm test && npm run lint|
  s|[LANGUAGE-SPECIFIC...]|TypeScript: Follow standard conventions|
  s|[LAST 3 FEATURES...]|- 003-user-auth: Added TypeScript 5.x + Next.js|
  3. 转换 \n 为实际换行符（第 351-352 行）

  代理文件路径映射（第 62-77 行）：
  - Claude: CLAUDE.md
  - Gemini: GEMINI.md
  - Copilot: .github/agents/copilot-instructions.md
  - Cursor: .cursor/rules/specify-rules.mdc
  - 其他 11 种代理...

  2.3.7 Constitution Check 机制

  定义位置：plan-template.md 第 30-34 行
  ## Constitution Check

  *GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

  [Gates determined based on constitution file]

  执行逻辑（commands 文件第 30 行）：
  - AI 读取 constitution.md 中定义的原则
  - 对照 Technical Context 检查是否有违规
  - 例如 constitution 定义"最多 3 个项目"，但 plan 显示 4 个 → 需要说明理由

  违规处理（plan-template.md 第 99-104 行）：
  ## Complexity Tracking

  | Violation | Why Needed | Simpler Alternative Rejected Because |
  |-----------|------------|-------------------------------------|
  | [e.g., 4th project] | [current need] | [why 3 projects insufficient] |

  2.3.8 Phase 0: Research 机制

  触发条件（commands 文件第 31、41-46 行）：
  - Technical Context 中存在 "NEEDS CLARIFICATION"

  执行流程：
  1. 提取所有未知项 → 生成研究任务列表
  2. 为每个技术选型创建"最佳实践"研究任务
  3. 派发研究代理（可能并行）
  4. 合并结果到 research.md，格式：
  ## [Decision Topic]
  - **Decision**: [what was chosen]
  - **Rationale**: [why chosen]
  - **Alternatives considered**: [what else evaluated]
  5. 用研究结果回填 Technical Context

  2.3.9 Phase 1: Design & Contracts

  任务 1：生成 data-model.md（commands 文件第 67-71 行）
  - 从 spec.md 的 Key Entities 部分提取
  - 添加字段、关系、验证规则
  - 如有状态转换，记录状态机

  任务 2：生成 contracts/（commands 文件第 72-76 行）
  - 从 spec.md 的 Functional Requirements 提取用户操作
  - 映射到 REST/GraphQL 端点
  - 输出 OpenAPI 或 GraphQL schema

  任务 3：生成 quickstart.md（目的：集成测试场景）

  任务 4：更新代理上下文（commands 文件第 77-83 行）
  .specify/scripts/bash/update-agent-context.sh claude
  - 从 plan.md 提取技术栈
  - 更新 CLAUDE.md（或其他代理文件）
  - 保留 <!-- MANUAL ADDITIONS START/END --> 之间的手动内容

  2.3.10 修改调整点

  调整点 A：为特定技术栈添加详细指导
  - 文件：.specify/templates/plan-template.md
  - 操作：
    a. 在 Technical Context 部分添加新字段（如 **CI/CD**: [...]）
    b. 在 update-agent-context.sh 第 156-206 行添加新字段提取逻辑
    c. 在 update-agent-context.sh 第 246-263 行添加新技术的命令生成规则

  调整点 B：修改项目结构选项
  - 文件：.specify/templates/plan-template.md 第 59-92 行
  - 操作：添加 Option 4、Option 5 等，或修改现有选项的目录结构
  - 影响：update-agent-context.sh 第 236-244 行的 get_project_structure() 需同步更新

  调整点 C：自定义 Constitution Check 规则
  - 文件：.specify/memory/constitution.md
  - 操作：在 Quality Gates 或 Core Principles 部分添加新原则
  - 影响：AI 在执行 /speckit.plan 时会自动使用新规则验证

  调整点 D：支持新的 AI 代理
  - 文件：.specify/scripts/bash/update-agent-context.sh
  - 操作：
    a. 第 62-77 行添加新代理的文件路径变量
    b. 第 584-642 行 update_specific_agent() 添加新 case
    c. 第 644-728 行 update_all_existing_agents() 添加新文件检查

  2.3.11 错误处理

  错误场景 1：plan.md 不存在
  - 触发位置：setup-plan.sh 调用 check_feature_branch() 失败
  - 错误信息：commands 文件未明确定义，由脚本报告
  - 处理：提示先运行 /speckit.specify

  错误场景 2：Constitution Check 失败且无说明
  - 触发位置：commands 文件第 30 行 ERROR if violations unjustified
  - 错误信息：列出违规项，要求填写 Complexity Tracking 表
  - 处理：用户必须在 plan.md 中说明理由或修改设计

  错误场景 3：Phase 0 研究后仍有 NEEDS CLARIFICATION
  - 触发位置：commands 文件第 61 行 "research.md with all NEEDS CLARIFICATION resolved"
  - 错误信息：未明确定义，由 AI 判断
  - 处理：重新执行研究或手动填写

  错误场景 4：update-agent-context.sh 执行失败
  - 可能原因：
    - plan.md 不可读（validate_environment 第 136-143 行）
    - 模板文件缺失（第 146-149 行）
    - 文件权限问题（第 556-564 行）
  - 日志输出：使用 log_error() 报告具体位置
  - 处理：检查文件权限，确保模板存在

  ---
  章节 2.4：/speckit.tasks - 任务分解生成

  2.4.1 命令概述
  - 职责：将技术计划分解为可执行任务清单
  - 前提：plan.md 和 spec.md 已完成
  - 输出：tasks.md（按用户故事组织的任务列表）

  2.4.2 执行流程图
  graph TD
      A[用户: /speckit.tasks] --> B[执行 check-prerequisites.sh --json]
      B --> C[获取 FEATURE_DIR, AVAILABLE_DOCS]
      C --> D[加载必需文档: plan.md, spec.md]
      D --> E[加载可选文档: data-model.md, contracts/, research.md]
      E --> F[从 spec.md 提取用户故事 + 优先级]
      F --> G[从 plan.md 提取技术栈和项目结构]
      G --> H{data-model.md 存在?}
      H -->|是| I[提取实体 → 映射到用户故事]
      H -->|否| J[跳过实体任务]
      I --> K{contracts/ 存在?}
      J --> K
      K -->|是| L[提取端点 → 映射到用户故事]
      K -->|否| M[跳过合约任务]
      L --> N[生成任务阶段结构]
      M --> N
      N --> O[Phase 1: Setup 项目初始化]
      O --> P[Phase 2: Foundational 基础设施]
      P --> Q[Phase 3+: 按优先级为每个用户故事生成阶段]
      Q --> R[Final Phase: Polish 优化和交叉关注点]
      R --> S[生成依赖关系图]
      S --> T[生成并行执行示例]
      T --> U[写入 tasks.md]
      U --> V[报告: 任务总数, 各故事任务数, 并行机会, MVP 范围]

  2.4.3 涉及文件清单
  - 命令定义：.claude/commands/speckit.tasks.md (138 行)
  - 脚本：.specify/scripts/bash/check-prerequisites.sh (167 行)
  - 模板：.specify/templates/tasks-template.md (252 行)
  - 输入文档：
    - specs/###-short-name/plan.md ✓ 必需
    - specs/###-short-name/spec.md ✓ 必需
    - specs/###-short-name/data-model.md ○ 可选
    - specs/###-short-name/contracts/ ○ 可选
    - specs/###-short-name/research.md ○ 可选
  - 输出：
    - specs/###-short-name/tasks.md

  2.4.4 脚本机制详解：check-prerequisites.sh

  参数选项（第 30-43 行）：
  - --json - JSON 格式输出
  - --require-tasks - 要求 tasks.md 存在（用于 /speckit.implement）
  - --include-tasks - 在 AVAILABLE_DOCS 中包含 tasks.md
  - --paths-only - 仅输出路径，不验证前置条件

  验证逻辑（第 102-120 行）：
  1. 检查 FEATURE_DIR 目录存在
  2. 检查 plan.md 存在（必需）
  3. 如果 --require-tasks，检查 tasks.md 存在
  4. 失败时给出明确提示（运行哪个命令）

  文档发现（第 123-139 行）：
  docs=()
  [[ -f "$RESEARCH" ]] && docs+=("research.md")
  [[ -f "$DATA_MODEL" ]] && docs+=("data-model.md")
  [[ -d "$CONTRACTS_DIR" && -n "$(ls -A "$CONTRACTS_DIR")" ]] && docs+=("contracts/")
  [[ -f "$QUICKSTART" ]] && docs+=("quickstart.md")
  $INCLUDE_TASKS && [[ -f "$TASKS" ]] && docs+=("tasks.md")

  JSON 输出格式（第 143-151 行）：
  {
    "FEATURE_DIR": "/path/to/specs/003-user-auth",
    "AVAILABLE_DOCS": ["research.md", "data-model.md", "contracts/", "quickstart.md"]
  }

  2.4.5 任务生成规则

  强制清单格式（commands 文件第 75-104 行）：
  - [ ] [TaskID] [P?] [Story?] Description with file path

  格式组件说明：
  1. Checkbox: - [ ] - Markdown 复选框
  2. Task ID: T001, T002... - 按执行顺序编号
  3. [P] marker: 可并行标记（不同文件、无依赖）
  4. [Story] label: [US1], [US2]... - 用户故事映射（仅故事阶段任务）
  5. Description: 明确操作 + 精确文件路径

  示例对比：
  - ✅ - [ ] T001 Create project structure per implementation plan
  - ✅ - [ ] T005 [P] Implement authentication middleware in src/middleware/auth.py
  - ✅ - [ ] T012 [P] [US1] Create User model in src/models/user.py
  - ❌ - [ ] Create User model (缺 ID 和路径)
  - ❌ T001 [US1] Create model (缺 checkbox)

  任务组织原则（commands 文件第 107-125 行）：

  从用户故事组织（主要）：
  - 每个用户故事（P1, P2, P3）= 一个独立阶段
  - 映射故事需要的所有组件：
    - Models → 该故事的实体
    - Services → 该故事的业务逻辑
    - Endpoints/UI → 该故事的接口
    - Tests → 该故事的测试（如果需要）
  - 故事间应尽量独立

  从合约/数据模型组织（辅助）：
  - 每个合约/端点 → 映射到服务它的用户故事
  - 每个实体 → 映射到需要它的用户故事（可能多个）
  - 如实体服务多故事 → 放入最早故事或 Setup 阶段

  阶段结构（commands 文件第 130-138 行）：
  1. Phase 1: Setup - 项目初始化
  2. Phase 2: Foundational - 阻塞性前置任务（必须先完成）
  3. Phase 3+: User Stories - 按优先级（P1, P2, P3...）
    - 每个故事内部：Tests → Models → Services → Endpoints → Integration
    - 每个阶段 = 独立可测试的增量
  4. Final Phase: Polish - 优化和交叉关注点

  2.4.6 依赖关系和并行策略

  阶段依赖（模板文件第 165-179 行）：
  - Setup → Foundational → 所有用户故事可并行 → Polish
  - Foundational 完成前，所有用户故事被阻塞
  - Foundational 完成后，故事间可并行（如有团队容量）

  用户故事依赖（模板文件第 175-178 行）：
  - US1 (P1)：仅依赖 Foundational，无其他故事依赖
  - US2 (P2)：仅依赖 Foundational，可能集成 US1 但应独立可测
  - US3 (P3)：同上

  故事内依赖（模板文件第 180-186 行）：
  - Tests 先写并失败（TDD）
  - Models 先于 Services
  - Services 先于 Endpoints
  - 核心实现先于集成
  - 故事完成后再进入下一优先级

  并行机会（模板文件第 188-195 行）：
  - Setup 阶段内所有 [P] 任务
  - Foundational 阶段内所有 [P] 任务
  - Foundational 完成后，所有用户故事阶段（跨故事并行）
  - 单个故事内：所有 tests [P]、所有 models [P]

  2.4.7 修改调整点

  调整点 A：修改任务拆分粒度

  更细粒度（拆分单个任务）：
  - 位置：生成的 tasks.md 或命令逻辑
  - 方法：
    a. 在 commands 文件添加任务拆分规则（如将"实现 Service"拆分为"实现验证"+"实现核心逻辑"+"实现错误处理"）
    b. 或在模板文件中添加更详细的任务示例
  - 影响：任务总数增加，每个任务更原子化

  更粗粒度（合并多个任务）：
  - 位置：同上
  - 方法：
    a. 减少阶段数量（如合并 Models 和 Services 为"业务层"）
    b. 或将多个相关文件的任务合并为一个
  - 影响：任务总数减少，每个任务范围更大

  调整点 B：为不同项目类型定制任务模板

  前端项目：
  - 文件：复制 tasks-template.md 为 tasks-template-frontend.md
  - 修改：
    - 替换 "Models" 为 "Components"
    - 替换 "Services" 为 "Hooks/Context"
    - 替换 "Endpoints" 为 "Pages/Routes"
    - 调整文件路径（如 src/components/ 替代 src/models/）
  - 在 commands 文件添加项目类型检测（从 plan.md 读取）

  后端 API 项目：
  - 保持现有模板
  - 可选添加：数据库迁移任务、API 文档生成任务

  移动应用：
  - 添加：UI 组件、导航流、平台特定任务（iOS/Android）
  - 调整路径：ios/src/ 或 android/src/

  调整点 C：自定义测试策略

  可选测试（默认行为）：
  - 当前规则：仅在 spec.md 明确要求或用户请求 TDD 时生成测试任务
  - 位置：commands 文件第 71 行 **Tests are OPTIONAL**

  强制测试：
  - 修改：commands 文件第 71 行改为 **Tests are REQUIRED**
  - 影响：每个用户故事都会生成测试任务，放在实现任务之前

  测试粒度调整：
  - 当前：Contract tests + Integration tests
  - 可添加：Unit tests（每个 model/service）
  - 位置：模板文件第 82-87 行，添加额外测试任务行

  调整点 D：自定义 MVP 范围定义

  当前逻辑（commands 文件第 61、模板文件第 76 行）：
  - MVP = Phase 1 (Setup) + Phase 2 (Foundational) + Phase 3 (User Story 1)

  修改为多故事 MVP：
  - 方法：在 commands 文件添加 MVP 标记逻辑
  - 标记多个故事为 MVP（如 P1 + P2）
  - 在 tasks.md 摘要中明确 MVP 范围

  2.4.8 错误处理

  错误场景 1：plan.md 不存在
  - 触发位置：check-prerequisites.sh 第 109-112 行
  - 错误信息：ERROR: plan.md not found in $FEATURE_DIR
  - 处理：提示运行 /speckit.plan

  错误场景 2：spec.md 缺失用户故事
  - 触发位置：commands 文件逻辑验证（AI 判断）
  - 错误信息：未明确定义，由 AI 报告
  - 处理：返回 /speckit.specify 补充用户故事

  错误场景 3：可选文档不存在
  - 触发位置：check-prerequisites.sh 第 126-134 行
  - 处理：不报错，继续生成任务但跳过相关任务类型
  - 示例：无 data-model.md → 不生成实体创建任务

  错误场景 4：任务格式验证失败
  - 触发位置：commands 文件第 61 行 "Format validation: Confirm ALL tasks follow the checklist format"
  - 检查内容：每个任务是否有 checkbox、ID、必要标签、文件路径
  - 处理：报告格式错误的任务，要求修正

  ---
  章节 2.5：/speckit.implement - 实施执行

  2.5.1 命令概述
  - 职责：按 tasks.md 逐任务执行代码实现
  - 前提：tasks.md 已生成，可选的 checklists/ 已完成
  - 输出：实际代码文件、更新的 tasks.md（标记已完成任务）

  2.5.2 执行流程图
  graph TD
      A[用户: /speckit.implement] --> B[执行 check-prerequisites.sh --json --require-tasks --include-tasks]
      B --> C{FEATURE_DIR/checklists/ 存在?}
      C -->|否| D[跳过清单检查]
      C -->|是| E[扫描所有清单文件]
      E --> F[统计: Total, Completed, Incomplete]
      F --> G{所有清单完成?}
      G -->|是| H[显示 PASS 表格, 自动继续]
      G -->|否| I[显示 FAIL 表格 + 未完成项]
      I --> J[询问: 是否继续实施?]
      J --> K{用户回答}
      K -->|no/wait/stop| L[停止执行]
      K -->|yes/proceed/continue| M[继续到加载文档]
      H --> M
      D --> M
      M --> N[加载 tasks.md, plan.md]
      N --> O[加载可选: data-model.md, contracts/, research.md, quickstart.md]
      O --> P{项目是 Git 仓库?}
      P -->|是| Q[创建/验证 .gitignore]
      P -->|否| R[跳过 Git 相关]
      Q --> S[检测其他忽略文件需求]
      R --> S
      S --> T[创建/验证 .dockerignore, .eslintignore 等]
      T --> U[解析 tasks.md 结构]
      U --> V[提取: 阶段, 依赖, 任务详情, 并行标记]
      V --> W[Phase 1: Setup - 执行所有任务]
      W --> X[标记完成任务为 X 在 tasks.md]
      X --> Y{Phase 1 成功?}
      Y -->|否| Z[停止, 报告错误]
      Y -->|是| AA[Phase 2: Foundational - 执行阻塞性任务]
      AA --> AB[标记完成]
      AB --> AC{Phase 2 成功?}
      AC -->|否| Z
      AC -->|是| AD[Phase 3+: User Stories - 按优先级执行]
      AD --> AE[执行当前故事的所有任务]
      AE --> AF[标记完成]
      AF --> AG{当前故事成功?}
      AG -->|否| AH[报告失败, 建议下一步]
      AG -->|是| AI{还有更多故事?}
      AI -->|是| AD
      AI -->|否| AJ[Final Phase: Polish - 执行优化任务]
      AJ --> AK[标记完成]
      AK --> AL[最终验证: 所有任务完成, 测试通过, 匹配规格]
      AL --> AM[报告完成状态 + 工作摘要]

  2.5.3 涉及文件清单
  - 命令定义：.claude/commands/speckit.implement.md (136 行)
  - 脚本：.specify/scripts/bash/check-prerequisites.sh (已在 2.4 节详述)
  - 输入文档：
    - specs/###-short-name/tasks.md ✓ 必需
    - specs/###-short-name/plan.md ✓ 必需
    - specs/###-short-name/checklists/ ○ 可选（如存在则验证）
    - specs/###-short-name/data-model.md ○ 可选
    - specs/###-short-name/contracts/ ○ 可选
    - specs/###-short-name/research.md ○ 可选
    - specs/###-short-name/quickstart.md ○ 可选
  - 输出：
    - 项目代码文件（根据 tasks.md 任务）
    - 更新的 specs/###-short-name/tasks.md（任务标记为 [X]）
    - 忽略文件（.gitignore, .dockerignore 等）

  2.5.4 清单验证机制

  检查逻辑（commands 文件第 17-42 行）：

  步骤 1：扫描清单文件
  # 伪代码示例
  for checklist in FEATURE_DIR/checklists/*.md; do
      total=$(grep -c '- \[ \]' "$checklist") + $(grep -c '- \[X\]' "$checklist")
      completed=$(grep -c '- \[X\]' "$checklist")
      incomplete=$(grep -c '- \[ \]' "$checklist")
  done

  步骤 2：生成状态表
  | Checklist       | Total | Completed | Incomplete | Status   |
  |-----------------|-------|-----------|------------|----------|
  | ux.md           | 12    | 12        | 0          | ✓ PASS   |
  | test.md         | 8     | 5         | 3          | ✗ FAIL   |
  | security.md     | 6     | 6         | 0          | ✓ PASS   |

  步骤 3：计算总体状态
  - PASS：所有清单的 Incomplete = 0
  - FAIL：至少一个清单的 Incomplete > 0

  步骤 4：用户交互（commands 文件第 37-42 行）
  - 如果 FAIL：
  Some checklists are incomplete. Do you want to proceed with implementation anyway? (yes/no)
    - 等待用户明确回答
    - "no" / "wait" / "stop" → 停止
    - "yes" / "proceed" / "continue" → 继续
  - 如果 PASS：自动继续

  2.5.5 忽略文件管理

  检测与创建逻辑（commands 文件第 56-99 行）：

  Git 仓库检测（第 60-65 行）：
  if git rev-parse --git-dir 2>/dev/null; then
      # 创建/验证 .gitignore
  fi

  其他忽略文件检测（第 66-72 行）：
  - Dockerfile* 存在 → .dockerignore
  - .eslintrc* 存在 → .eslintignore
  - eslint.config.* 存在 → 验证 config 的 ignores 条目
  - .prettierrc* 存在 → .prettierignore
  - package.json 存在 → .npmignore（如发布）
  - *.tf 存在 → .terraformignore
  - Helm charts 存在 → .helmignore

  已存在文件处理（第 74-75 行）：
  - 验证包含基本模式
  - 仅追加缺失的关键模式

  通用模式库（第 77-99 行）：
  - Node.js: node_modules/, dist/, build/, *.log, .env*
  - Python: __pycache__/, *.pyc, .venv/, dist/, *.egg-info/
  - Rust: target/, debug/, release/, *.rs.bk, *.rlib
  - TypeScript: node_modules/, dist/, build/, *.log, .env*
  - Universal: .DS_Store, Thumbs.db, *.tmp, .vscode/, .idea/
  - Docker: node_modules/, .git/, *.log*, .env*, coverage/
  - Terraform: .terraform/, *.tfstate*, *.tfvars

  技术栈检测（从 plan.md）：
  - 读取 **Language/Version**: 字段
  - 匹配关键字（Python/JavaScript/Rust/Java 等）
  - 应用对应模式集

  2.5.6 任务执行规则

  阶段执行顺序（commands 文件第 106-119 行）：
  1. Setup first - 项目结构、依赖、配置
  2. Tests before code - 如果有测试任务（TDD）
  3. Core development - Models → Services → CLI/Endpoints
  4. Integration work - 数据库、中间件、日志、外部服务
  5. Polish and validation - 单元测试、性能、文档

  依赖遵守（commands 文件第 107-111 行）：
  - 顺序任务：按 ID 顺序执行（T001 → T002 → T003）
  - 并行任务 [P]：可同时执行（不同文件、无依赖）
  - 文件冲突检测：影响同一文件的任务必须顺序执行

  验证检查点（commands 文件第 111 行）：
  - 每个阶段完成后验证成功才进入下一阶段

  2.5.7 进度跟踪和错误处理

  进度报告（commands 文件第 121-127 行）：
  - 每个任务完成后报告
  - 更新 tasks.md：- [ ] → - [X]（第 126 行 IMPORTANT）
  - 示例：
  ✓ T012 [P] [US1] Create User model in src/models/user.py

  错误处理策略（commands 文件第 122-125 行）：

  非并行任务失败：
  - 停止执行整个流程
  - 提供明确错误消息 + 上下文
  - 建议下一步操作

  并行任务失败：
  - 继续执行其他成功的并行任务
  - 报告失败任务列表
  - 完成所有可完成任务后再处理失败

  失败消息格式：
  ERROR in T025: Failed to implement UserService
  Context: User model dependency not found
  File: src/services/user_service.py
  Next steps:
  1. Verify T012 (User model) completed successfully
  2. Check import paths in service file
  3. Re-run /speckit.implement to resume from T025

  2.5.8 完成验证

  验证清单（commands 文件第 128-133 行）：
  1. ✓ 所有必需任务已完成
  2. ✓ 实现的功能匹配 spec.md
  3. ✓ 测试通过且覆盖率满足要求
  4. ✓ 实现遵循 plan.md 的技术计划

  最终状态报告：
  Implementation Complete

  Tasks Summary:
  - Total: 42 tasks
  - Completed: 42
  - Failed: 0
  - Skipped: 0

  User Stories Delivered:
  - ✓ US1: User Authentication (P1) - MVP
  - ✓ US2: Profile Management (P2)
  - ✓ US3: Settings (P3)

  Next Steps:
  - Run tests: npm test
  - Review quickstart.md for integration scenarios
  - Consider running /speckit.analyze for consistency check

  2.5.9 修改调整点

  调整点 A：自定义忽略文件模式

  添加新技术栈：
  - 文件：.claude/commands/speckit.implement.md
  - 位置：第 77-99 行的通用模式库
  - 操作：添加新语言/框架的忽略模式
  - 示例：
  - **Elixir**: _build/, deps/, *.ez, .fetch, erl_crash.dump

  调整现有模式：
  - 修改对应技术栈的模式列表
  - 影响：新项目会使用新模式

  调整点 B：修改清单检查策略

  强制清单完成：
  - 位置：commands 文件第 37-42 行
  - 修改：移除用户选择逻辑，直接停止如果 FAIL
  - 代码示例：
  - **If any checklist is incomplete**:
    - Display the table with incomplete item counts
    - **STOP with error** (remove user prompt)

  跳过清单检查：
  - 位置：commands 文件第 17 行
  - 修改：移除整个清单检查步骤（17-42 行）

  调整点 C：自定义错误恢复策略

  添加自动重试：
  - 位置：commands 文件第 122 行 "Halt execution if any non-parallel task fails"
  - 修改：添加重试逻辑（最多 3 次）
  - 实现：在命令文件中详细说明重试条件和次数

  保存断点状态：
  - 添加：在 tasks.md 同目录创建 .implementation-state.json
  - 内容：
  {
    "last_completed_task": "T024",
    "current_phase": "Phase 4: User Story 2",
    "failed_tasks": ["T025"],
    "timestamp": "2026-01-19T10:30:00Z"
  }
  - 用途：重新运行命令时从断点恢复

  调整点 D：为特定阶段添加自定义验证

  Phase 2 完成后运行测试：
  - 位置：commands 文件第 111 行 "Validation checkpoints"
  - 添加：明确指示在 Foundational 阶段后运行基础测试
  - 示例：
  After Phase 2 completion:
  - Run foundational tests: npm run test:foundation
  - Verify database connectivity
  - Check environment variables loaded

  User Story 完成后运行故事测试：
  - 类似上述，为每个故事阶段添加验证步骤

  2.5.10 错误处理

  错误场景 1：tasks.md 不存在
  - 触发位置：check-prerequisites.sh --require-tasks 标志
  - 错误信息：ERROR: tasks.md not found in $FEATURE_DIR
  - 处理：提示运行 /speckit.tasks

  错误场景 2：清单未完成且用户拒绝继续
  - 触发位置：commands 文件第 39-42 行
  - 处理：停止执行，退出命令
  - 用户后续：完成清单或强制跳过

  错误场景 3：关键任务执行失败
  - 触发位置：任务执行过程中
  - 错误信息：包含任务 ID、文件路径、具体错误、上下文
  - 处理：停止流程，标记失败任务，建议修复步骤

  错误场景 4：测试失败
  - 触发位置：commands 文件第 131 行验证
  - 错误信息：显示失败的测试用例
  - 处理：
    - 列出失败测试
    - 不标记实现任务为完成
    - 建议修复代码或测试

  错误场景 5：忽略文件创建失败
  - 触发位置：文件写入权限问题
  - 处理：警告但不停止，继续实施
  - 日志：记录无法创建的文件

  ---
  第三部分：脚本协同机制深度解析（约 2000 字）

  章节 3.1：脚本基础设施层

  3.1.1 common.sh - 共享函数库

  核心功能（第 4-152 行）：
  1. get_repo_root() - 仓库根目录解析
  2. get_current_branch() - 当前分支获取（支持 Git 和非 Git）
  3. has_git() - Git 可用性检测
  4. check_feature_branch() - 分支名验证
  5. get_feature_dir() - 特性目录路径
  6. find_feature_dir_by_prefix() - 按前缀查找目录（支持多分支）
  7. get_feature_paths() - 所有路径变量生成
  8. check_file() / check_dir() - 文件/目录检查助手

  路径解析优先级（get_current_branch 第 16-58 行）：
  1. 环境变量 $SPECIFY_FEATURE（最高优先级）
  2. Git 分支名 git rev-parse --abbrev-ref HEAD
  3. specs/ 目录中最高编号的特性目录
  4. 回退到 "main"

  多分支支持（find_feature_dir_by_prefix 第 88-125 行）：
  - 允许多个分支共享同一个 spec 目录
  - 示例：004-fix-bug 和 004-add-feature 都使用 specs/004-main-feature/
  - 通过提取数字前缀（如 "004"）匹配目录

  输出格式（get_feature_paths 第 139-152 行）：
  REPO_ROOT='/path/to/repo'
  CURRENT_BRANCH='003-user-auth'
  HAS_GIT='true'
  FEATURE_DIR='/path/to/repo/specs/003-user-auth'
  FEATURE_SPEC='/path/to/repo/specs/003-user-auth/spec.md'
  IMPL_PLAN='/path/to/repo/specs/003-user-auth/plan.md'
  TASKS='/path/to/repo/specs/003-user-auth/tasks.md'
  RESEARCH='/path/to/repo/specs/003-user-auth/research.md'
  DATA_MODEL='/path/to/repo/specs/003-user-auth/data-model.md'
  QUICKSTART='/path/to/repo/specs/003-user-auth/quickstart.md'
  CONTRACTS_DIR='/path/to/repo/specs/003-user-auth/contracts'

  3.1.2 脚本调用时序

  命令 → 脚本映射：
  /speckit.constitution
    └─ (无脚本调用，纯 AI 逻辑)

  /speckit.specify
    └─ create-new-feature.sh --json "$ARGUMENTS"
        ├─ 输入：特性描述、可选 --short-name、--number
        └─ 输出：BRANCH_NAME, SPEC_FILE, FEATURE_NUM

  /speckit.plan
    ├─ setup-plan.sh --json
    │   └─ 输出：FEATURE_SPEC, IMPL_PLAN, SPECS_DIR, BRANCH, HAS_GIT
    └─ update-agent-context.sh claude
        ├─ 解析：plan.md 技术字段
        └─ 更新：CLAUDE.md

  /speckit.tasks
    └─ check-prerequisites.sh --json
        ├─ 验证：FEATURE_DIR, plan.md 存在
        └─ 输出：FEATURE_DIR, AVAILABLE_DOCS

  /speckit.implement
    └─ check-prerequisites.sh --json --require-tasks --include-tasks
        ├─ 验证：FEATURE_DIR, plan.md, tasks.md 存在
        └─ 输出：FEATURE_DIR, AVAILABLE_DOCS (含 tasks.md)

  JSON 通信协议：
  - 所有脚本支持 --json 标志
  - AI 解析 JSON 提取路径变量
  - 确保跨平台兼容（Bash/PowerShell 均支持）

  3.1.3 错误传播机制

  Bash 严格模式（所有脚本第 1-5 行）：
  #!/usr/bin/env bash
  set -e          # 任何命令失败立即退出
  set -u          # 使用未定义变量报错
  set -o pipefail # 管道中任一命令失败则失败

  日志函数（update-agent-context.sh 第 92-106 行）：
  log_info()    { echo "INFO: $1"; }
  log_success() { echo "✓ $1"; }
  log_error()   { echo "ERROR: $1" >&2; }  # 输出到 stderr
  log_warning() { echo "WARNING: $1" >&2; }

  退出码约定：
  - 0 = 成功
  - 1 = 通用错误
  - 特定错误码（如需要）在脚本文档中定义

  清理机制（update-agent-context.sh 第 109-117 行）：
  cleanup() {
      local exit_code=$?
      rm -f /tmp/agent_update_*_$$  # 清理临时文件
      exit $exit_code
  }
  trap cleanup EXIT INT TERM

  ---
  章节 3.2：占位符替换规则完整指南

  3.2.1 占位符类型分类

  类型 A：方括号占位符 [PLACEHOLDER]
  - 替换者：AI 或人工
  - 时机：命令执行时填充
  - 示例：
    - [FEATURE NAME] → "User Authentication"
    - [DATE] → "2026-01-19"
    - [Brief Title] → "Login Flow"

  类型 B：美元符号变量 $VARIABLE
  - 替换者：脚本或系统
  - 时机：脚本执行时替换
  - 示例：
    - $ARGUMENTS → 用户输入的原始文本
    - $BRANCH_NAME → "003-user-auth"

  类型 C：特殊标记 [NEEDS CLARIFICATION: ...]
  - 用途：标记需要用户澄清的内容
  - 限制：最多 3 个（spec.md）
  - 处理：生成选项表询问用户 → 替换为用户回答

  3.2.2 模板文件占位符索引

  spec-template.md：
  [FEATURE NAME]              → 功能名称（AI 从描述提取）
  [###-feature-name]          → 分支名（脚本生成）
  [DATE]                      → 创建日期（系统）
  $ARGUMENTS                  → 用户输入（脚本注入）
  [Brief Title]               → 用户故事标题（AI 填充，可重复）
  [Describe this user...]     → 故事描述（AI 填充）
  [Why this priority]         → 优先级理由（AI 填充）
  [Independent Test]          → 独立测试说明（AI 填充）
  [initial state]             → Given 场景（AI 填充）
  [action]                    → When 操作（AI 填充）
  [expected outcome]          → Then 结果（AI 填充）
  [boundary condition]        → 边界条件（AI 填充）
  [error scenario]            → 错误场景（AI 填充）
  [specific capability]       → 功能需求（AI 填充）
  [Entity 1/2]                → 实体名称（AI 填充）
  [Measurable metric]         → 成功标准（AI 填充）
  [NEEDS CLARIFICATION: ...] → 待澄清问题（AI 标记，最多 3 个）

  plan-template.md：
  [FEATURE]                   → 功能名称
  [###-feature-name]          → 分支名
  [DATE]                      → 日期
  [link]                      → spec.md 相对路径
  [Extract from feature spec] → 摘要（AI 从 spec 提取）
  [e.g., Python 3.11... or NEEDS CLARIFICATION] → 语言版本（AI 填充或标记）
  [e.g., FastAPI... or NEEDS CLARIFICATION]     → 框架（AI 填充或标记）
  [if applicable... or N/A]                     → 存储（AI 判断）
  [Gates determined based on constitution]      → 质量门（AI 从 constitution 生成）
  [REMOVE IF UNUSED] Option 1/2/3               → 项目结构（AI 选择并移除未用选项）

  tasks-template.md：
  [FEATURE NAME]              → 功能名称
  [###-feature-name]          → 分支名
  [Title]                     → 用户故事标题（从 spec 提取）
  [Brief description]         → 故事目标（从 spec 提取）
  [How to verify]             → 独立测试方法（从 spec 提取）
  [language]                  → 编程语言（从 plan 提取）
  [framework]                 → 框架名（从 plan 提取）
  [endpoint]                  → API 端点（从 contracts 提取）
  [Entity1/Entity2]           → 实体名（从 data-model 提取）
  [Service]                   → 服务名（AI 推导）
  [name]                      → 文件/测试名（AI 推导）
  [location]                  → 文件位置（从 plan 的项目结构推导）

  agent-file-template.md：
  [PROJECT NAME]              → 项目名（从目录名提取）
  [DATE]                      → 日期（系统）
  [EXTRACTED FROM ALL PLAN.MD FILES] → 技术栈列表（脚本从所有 plan.md 汇总）
  [ACTUAL STRUCTURE FROM PLANS]      → 项目结构（脚本从 plan.md 提取）
  [ONLY COMMANDS FOR ACTIVE TECHNOLOGIES] → 命令（脚本根据语言生成）
  [LANGUAGE-SPECIFIC, ONLY FOR LANGUAGES IN USE] → 代码风格（脚本根据语言生成）
  [LAST 3 FEATURES AND WHAT THEY ADDED] → 最近变更（脚本维护，最多 3 条）

  constitution.md：
  [PROJECT_NAME]              → 项目名
  [CONSTITUTION_VERSION]      → 版本号（语义化，AI 递增）
  [RATIFICATION_DATE]         → 首次通过日期（AI 或用户提供）
  [LAST_AMENDED_DATE]         → 最后修订日期（系统日期）
  [PRINCIPLE_N_NAME]          → 原则 N 的名称（AI 或用户提供，N 可变）
  [Principle N content]       → 原则 N 的内容（AI 或用户提供）

  3.2.3 自定义占位符添加流程

  步骤 1：在模板中添加占位符
  - 文件：对应的 .specify/templates/*.md
  - 格式：[YOUR_CUSTOM_PLACEHOLDER]
  - 位置：需要动态内容的地方

  步骤 2：在命令文件中添加替换逻辑
  - 文件：.claude/commands/speckit.<command>.md
  - 位置：Outline 部分的填充步骤
  - 指示 AI 如何生成该占位符的值

  示例：
  # 模板中 (spec-template.md)
  **Estimated Complexity**: [COMPLEXITY_SCORE]

  # 命令文件中 (speckit.specify.md)
  5. Fill Complexity Score:
     - Analyze functional requirements count
     - Analyze entity relationships count
     - Calculate score: Simple (1-10 FRs, 1-3 entities) | Medium (11-20 FRs, 4-6 entities) | Complex (20+ FRs, 7+ entities)
     - Replace [COMPLEXITY_SCORE] with result

  步骤 3：如需脚本支持，添加 sed 替换
  - 文件：对应脚本（如 update-agent-context.sh）
  - 位置：substitutions 数组
  - 示例：
  substitutions=(
      ...
      "s|\[YOUR_CUSTOM_PLACEHOLDER\]|$computed_value|"
  )

  3.2.4 占位符验证机制

  验证时机：
  - constitution 命令：第 59-63 行 "No remaining unexplained bracket tokens"
  - 其他命令：隐式（AI 检查模板是否完全填充）

  验证方法：
  # 检查剩余占位符
  grep -n '\[.*\]' spec.md | grep -v '^\s*-'  # 排除列表项

  允许的例外：
  - 有意保留的占位符（如待办事项）
  - 必须在文档中明确说明理由

  ---
  章节 3.3：验证机制和错误处理策略

  3.3.1 三层错误处理架构

  层级 1：Bash 脚本级别
  set -e -u -o pipefail  # 严格模式
  log_error "message"    # 错误日志
  exit 1                 # 非零退出码

  层级 2：命令逻辑级别
  - 前置条件检查（文件存在性、分支有效性）
  - 质量门验证（Constitution Check、清单验证）
  - NEEDS CLARIFICATION 处理（限制数量、强制解决）
  - ERROR 关键字标记（明确错误条件）

  层级 3：工作流级别
  - 阶段依赖验证（前一阶段必须成功）
  - 文档完整性检查（check-prerequisites.sh）
  - 任务完成度追踪（tasks.md 复选框）
  - 最终交付验证（测试通过、匹配规格）

  3.3.2 验证清单汇总

  Constitution 验证（constitution 命令第 58-63 行）：
  - 无剩余方括号占位符（除有说明的）
  - 版本号匹配报告
  - 日期 ISO 8601 格式
  - 原则可测性（避免"should"等模糊词）

  Specification 验证（specify 命令第 103-140 行质量清单）：
  - 无实现细节（语言、框架、API）
  - 聚焦用户价值和业务需求
  - 面向非技术利益相关者
  - 所有必需章节完成
  - 无 NEEDS CLARIFICATION 标记
  - 需求可测试且明确
  - 成功标准可衡量
  - 成功标准技术无关
  - 所有验收场景已定义
  - 边界情况已识别
  - 范围明确界定
  - 依赖和假设已识别

  Plan 验证（plan 命令第 30、89 行）：
  - Constitution Check 通过或有合理违规说明
  - 所有 NEEDS CLARIFICATION 已解决（Phase 0）
  - Technical Context 所有字段非空或标记 N/A
  - 项目结构选项已选定（移除未用选项）

  Tasks 验证（tasks 命令第 61 行）：
  - 所有任务格式正确（checkbox + ID + 标签 + 路径）
  - 任务 ID 连续无跳号
  - 并行标记 [P] 仅用于无依赖任务
  - 用户故事标签 [USN] 正确映射
  - 每个阶段有明确目标和测试标准

  Implementation 验证（implement 命令第 128-133 行）：
  - 所有必需任务已完成
  - 实现功能匹配 spec.md
  - 测试通过且覆盖率足够
  - 实现遵循 plan.md 技术计划

  3.3.3 错误诊断步骤指南

  步骤 1：确定错误发生的命令
  - 查看命令输出的错误信息
  - 识别是哪个命令报告的错误

  步骤 2：定位错误类型
  - 脚本错误：查看 Bash 输出，通常包含脚本名和行号
  - 验证错误：查看质量清单或 ERROR 消息
  - 前置条件错误：check-prerequisites.sh 的输出

  步骤 3：收集诊断信息
  # 检查当前分支
  git rev-parse --abbrev-ref HEAD

  # 检查目录结构
  ls -la specs/

  # 检查可用文档
  .specify/scripts/bash/check-prerequisites.sh

  # 检查 plan.md 字段
  grep '^\*\*.*\*\*: ' specs/003-user-auth/plan.md

  步骤 4：查找 NEEDS CLARIFICATION
  grep -r "NEEDS CLARIFICATION" specs/003-user-auth/

  步骤 5：验证模板占位符
  # 检查未替换的占位符
  grep -E '\[.*\]' specs/003-user-auth/spec.md | grep -v '^\s*-'

  步骤 6：查看脚本 JSON 输出
  # 手动运行脚本查看详细输出
  .specify/scripts/bash/create-new-feature.sh --json "Test feature"
  .specify/scripts/bash/setup-plan.sh --json
  .specify/scripts/bash/check-prerequisites.sh --json

  3.3.4 常见错误场景速查表
  错误信息: "Not on a feature branch"
  可能原因: 当前分支名不符合 ###-name 格式
  解决方法: 运行 /speckit.specify 创建新特性
  涉及文件: common.sh:75
  ────────────────────────────────────────
  错误信息: "plan.md not found"
  可能原因: 未运行 plan 命令
  解决方法: 运行 /speckit.plan
  涉及文件: check-prerequisites.sh:109
  ────────────────────────────────────────
  错误信息: "tasks.md not found"
  可能原因: 未运行 tasks 命令
  解决方法: 运行 /speckit.tasks
  涉及文件: check-prerequisites.sh:116
  ────────────────────────────────────────
  错误信息: "ERROR if violations unjustified"
  可能原因: Constitution Check 失败
  解决方法: 填写 Complexity Tracking 表或修改设计
  涉及文件: plan.md:99, plan 命令:30
  ────────────────────────────────────────
  错误信息: "No feature description provided"
  可能原因: /speckit.specify 无参数
  解决方法: 提供特性描述作为参数
  涉及文件: specify 命令:76
  ────────────────────────────────────────
  错误信息: "Cannot determine user scenarios"
  可能原因: 描述太模糊
  解决方法: 提供更详细的用户场景描述
  涉及文件: specify 命令:88
  ────────────────────────────────────────
  错误信息: "Template not found"
  可能原因: agent-file-template.md 缺失
  解决方法: 确保 .specify/templates/ 完整
  涉及文件: update-agent-context.sh:276
  ────────────────────────────────────────
  错误信息: "Branch name exceeded 244 bytes"
  可能原因: 生成的分支名太长
  解决方法: 使用 --short-name 提供更短名称
  涉及文件: create-new-feature.sh:256
  ────────────────────────────────────────
  错误信息: "Checklist incomplete"
  可能原因: 清单验证失败
  解决方法: 完成清单或选择继续
  涉及文件: implement 命令:37
  3.3.5 自定义验证规则添加方法

  方法 A：在命令文件中添加验证步骤
  - 位置：Outline 部分的适当阶段
  - 示例（specify 命令）：
  7. Custom Validation: Check API naming conventions
     - Extract all endpoint names from Functional Requirements
     - Verify they follow REST conventions (GET /resources, POST /resources, etc.)
     - If violations found: WARN user with suggested corrections

  方法 B：在脚本中添加验证函数
  - 位置：对应脚本（如 check-prerequisites.sh）
  - 示例：
  validate_api_naming() {
      local contracts_dir="$1"
      # 检查 contracts/ 中的 API 命名
      # 返回 0（成功）或 1（失败）
  }

  # 在主逻辑中调用
  if [[ -d "$CONTRACTS_DIR" ]]; then
      validate_api_naming "$CONTRACTS_DIR" || exit 1
  fi

  方法 C：在 constitution 中定义规则
  - 位置：.specify/memory/constitution.md
  - 添加新原则或质量门
  - AI 会自动在相关命令中应用这些规则

  ---
  第四部分：场景驱动调整指南（约 2500 字）

  章节 4.1：场景 A - 调整任务拆分粒度

  4.1.1 需求场景
  您的项目规模或团队偏好可能需要不同的任务粒度：
  - 更细粒度：单人开发、学习目的、严格跟踪进度
  - 更粗粒度：经验丰富团队、快速原型、减少管理开销

  4.1.2 当前默认粒度
  - 一个任务 = 一个文件的创建或主要修改
  - 示例：T012 [P] [US1] Create User model in src/models/user.py

  4.1.3 调整为更细粒度

  修改位置 1：模板示例
  - 文件：.specify/templates/tasks-template.md
  - 当前（第 91-96 行）：
  - [ ] T012 [P] [US1] Create User model in src/models/user.py
  - [ ] T014 [US1] Implement UserService in src/services/user_service.py
  - 修改为：
  - [ ] T012 [P] [US1] Define User model schema in src/models/user.py
  - [ ] T013 [US1] Add User model validation logic in src/models/user.py
  - [ ] T014 [US1] Add User model to database mapping in src/models/user.py
  - [ ] T015 [US1] Implement UserService core logic in src/services/user_service.py
  - [ ] T016 [US1] Implement UserService error handling in src/services/user_service.py
  - [ ] T017 [US1] Implement UserService logging in src/services/user_service.py

  修改位置 2：命令逻辑
  - 文件：.claude/commands/speckit.tasks.md
  - 添加详细拆分指导（插入到第 39 行后）：
  3. **Task Granularity Rules** (for this project):
     - Models: Split into schema definition → validation → database mapping
     - Services: Split into core logic → error handling → logging
     - Endpoints: Split into routing → request validation → response formatting
     - Each subtask should be completable in < 30 minutes

  修改位置 3：并行标记调整
  - 更细粒度后，同一文件的不同部分任务不能并行
  - 移除 [P] 标记从细分任务：
  - [ ] T012 [US1] Define User model schema (无 [P]，因后续任务依赖它)
  - [ ] T013 [US1] Add User model validation (无 [P]，依赖 T012)

  影响分析：
  - 任务总数增加 2-3 倍
  - 每个任务更原子化，更易完成和验证
  - 进度跟踪更精细
  - 并行机会可能减少（文件内依赖增加）

  4.1.4 调整为更粗粒度

  修改位置 1：模板示例
  - 当前：分离 Models、Services、Endpoints 任务
  - 修改为：
  - [ ] T012 [P] [US1] Implement User authentication flow in src/auth/ (includes model, service, endpoints)

  修改位置 2：命令逻辑
  - 文件：.claude/commands/speckit.tasks.md
  - 修改组织原则（第 107-125 行）：
  1. **From User Stories** - PRIMARY ORGANIZATION:
     - Each user story = 3-5 high-level tasks (not per-component breakdown)
     - Combine related components into feature slices:
       - Authentication Flow = User model + AuthService + Login/Logout endpoints
       - Profile Management = Profile model + ProfileService + CRUD endpoints

  修改位置 3：阶段合并
  - 合并 Setup + Foundational 为 "Initialization"
  - 合并多个低优先级用户故事为 "Additional Features"

  影响分析：
  - 任务总数减少 50-70%
  - 每个任务范围更大，需要更多时间
  - 适合经验丰富的开发者
  - 进度跟踪较粗略

  4.1.5 调整验证

  修改后运行测试：
  # 1. 创建测试特性
  /speckit.specify "Add simple CRUD API"

  # 2. 生成计划
  /speckit.plan "Use Express.js"

  # 3. 生成任务（应用新粒度）
  /speckit.tasks

  # 4. 检查 tasks.md
  cat specs/004-crud-api/tasks.md | grep '- \[ \]' | wc -l
  # 细粒度：预期 40-60 任务
  # 粗粒度：预期 10-20 任务

  ---
  章节 4.2：场景 B - 适配不同项目类型（前端 vs 后端）

  4.2.1 需求场景
  不同类型项目需要不同的模板结构：
  - 前端 UI 项目：组件、页面、状态管理、样式
  - 后端 API 项目：模型、服务、端点、中间件
  - 全栈项目：两者结合
  - CLI 工具：命令、参数解析、输出格式

  4.2.2 当前默认配置
  - 偏向后端 API 结构（Models, Services, Endpoints）
  - 项目结构选项支持 Web（frontend + backend）和 Mobile

  4.2.3 为前端项目创建专属模板

  步骤 1：复制并修改 spec-template
  cd .specify/templates/
  cp spec-template.md spec-template-frontend.md

  步骤 2：调整章节结构
  - 文件：spec-template-frontend.md
  - 修改 Key Entities 为 Key Components：
  ### Key Components *(include if feature involves UI)*

  - **[Component 1]**: [What it displays, user interactions, props]
  - **[Component 2]**: [State it manages, events it handles]

  步骤 3：添加前端特定章节
  - 插入到 Success Criteria 之前：
  ### UI/UX Requirements *(mandatory for frontend)*

  - **Layout**: [Responsive design requirements, breakpoints]
  - **Interactions**: [Animations, transitions, feedback]
  - **Accessibility**: [Keyboard navigation, ARIA labels, screen reader support]
  - **Performance**: [Load time, render time, bundle size]

  步骤 4：修改 tasks-template
  cp tasks-template.md tasks-template-frontend.md

  步骤 5：调整任务类别
  - 文件：tasks-template-frontend.md
  - 替换（第 91-96 行）：
  # 原：Models → Services → Endpoints
  # 改为：
  - [ ] T012 [P] [US1] Create LoginForm component in src/components/auth/LoginForm.tsx
  - [ ] T013 [P] [US1] Create AuthContext provider in src/contexts/AuthContext.tsx
  - [ ] T014 [US1] Implement login hook in src/hooks/useAuth.ts
  - [ ] T015 [US1] Create login page in src/pages/LoginPage.tsx
  - [ ] T016 [US1] Add routing for login in src/App.tsx

  步骤 6：在 specify 命令中添加模板选择
  - 文件：.claude/commands/speckit.specify.md
  - 插入到第 100 行（写入规格前）：
  5a. **Detect Project Type** (from user description or explicit flag):
      - If description contains "frontend", "UI", "component", "React", "Vue", "Angular" → Frontend
      - If description contains "API", "backend", "server", "database" → Backend
      - If description contains both or "fullstack" → Fullstack
      - Default: Backend

  5b. **Select Template**:
      - Frontend → use spec-template-frontend.md
      - Backend → use spec-template.md (default)
      - Fullstack → use spec-template.md with both sections

  步骤 7：在 tasks 命令中添加模板选择
  - 文件：.claude/commands/speckit.tasks.md
  - 插入到第 32 行（生成任务前）：
  3a. **Detect Project Type** (from plan.md **Project Type** field):
      - Read plan.md → **Project Type**: [single/web/mobile]
      - If web + spec.md has UI/UX Requirements → Frontend tasks template
      - Else → Default tasks template

  3b. **Load Template**:
      - Frontend → .specify/templates/tasks-template-frontend.md
      - Backend → .specify/templates/tasks-template.md

  4.2.4 为后端项目优化现有模板

  已优化部分：
  - Models, Services, Endpoints 结构
  - Contract tests（API 合约测试）
  - Database schema 和 migrations

  可进一步优化：
  1. 添加中间件任务（plan-template.md 和 tasks-template.md）：
  - [ ] T008 [P] Implement authentication middleware in src/middleware/auth.ts
  - [ ] T009 [P] Implement logging middleware in src/middleware/logger.ts
  2. 添加数据库迁移任务：
  Phase 2: Foundational
  - [ ] T004 Create initial database migration in migrations/001_create_users_table.sql
  - [ ] T005 Setup migration runner script in scripts/migrate.sh
  3. 添加 API 文档任务：
  Final Phase: Polish
  - [ ] TXXX Generate OpenAPI documentation from contracts/
  - [ ] TXXX Setup Swagger UI at /api/docs endpoint

  4.2.5 为 CLI 工具创建专属模板

  步骤 1：创建 spec-template-cli.md
  - 关键章节调整：
    - User Stories → Command Scenarios
    - Key Entities → Command Structure
    - 添加：Command Arguments & Flags

  步骤 2：创建 tasks-template-cli.md
  - 任务类别：
  - [ ] T012 [P] [CMD1] Implement argument parser in src/cli/parser.ts
  - [ ] T013 [CMD1] Implement command handler in src/commands/init.ts
  - [ ] T014 [CMD1] Add output formatter in src/formatters/table.ts
  - [ ] T015 [CMD1] Add help text in src/help/init-help.ts

  4.2.6 验证项目类型适配

  测试前端模板：
  /speckit.specify "Build a photo gallery component with lightbox and thumbnails. Users can navigate photos with keyboard
  arrows."

  # 检查生成的 spec.md
  grep "UI/UX Requirements" specs/005-photo-gallery/spec.md
  # 应存在该章节

  /speckit.tasks
  # 检查任务类型
  grep "component" specs/005-photo-gallery/tasks.md
  grep "hooks" specs/005-photo-gallery/tasks.md

  测试后端模板：
  /speckit.specify "Build a REST API for managing blog posts with CRUD operations"

  # 检查任务类型
  grep "model" specs/006-blog-api/tasks.md
  grep "endpoint" specs/006-blog-api/tasks.md

  ---
  章节 4.3：场景 C - 为特定技术栈添加详细指导

  4.3.1 需求场景
  某些技术栈需要特定的：
  - 项目结构约定
  - 构建/测试命令
  - 最佳实践指导
  - 特定工具配置

  4.3.2 添加 Rust 技术栈支持示例

  步骤 1：扩展 plan-template.md
  - 文件：.specify/templates/plan-template.md
  - 插入到 Technical Context 部分（第 28 行后）：
  **Rust-Specific**:
  - **Edition**: [e.g., 2021 or NEEDS CLARIFICATION]
  - **Async Runtime**: [e.g., tokio, async-std, or N/A]
  - **Error Handling**: [e.g., anyhow, thiserror, or standard Result]
  - **Serialization**: [e.g., serde with JSON/TOML or N/A]

  步骤 2：扩展 update-agent-context.sh
  - 文件：.specify/scripts/bash/update-agent-context.sh
  - 添加字段提取（第 183-186 行后）：
  parse_plan_data() {
      # 现有字段...
      NEW_LANG=$(extract_plan_field "Language/Version" "$plan_file")

      # 新增 Rust 特定字段
      if [[ "$NEW_LANG" == *"Rust"* ]]; then
          NEW_RUST_EDITION=$(extract_plan_field "Edition" "$plan_file")
          NEW_RUST_ASYNC=$(extract_plan_field "Async Runtime" "$plan_file")
          NEW_RUST_ERROR=$(extract_plan_field "Error Handling" "$plan_file")
      fi
  }

  步骤 3：添加 Rust 命令生成
  - 位置：第 246-263 行 get_commands_for_language()
  - 添加 Rust case：
  get_commands_for_language() {
      local lang="$1"

      case "$lang" in
          # 现有语言...
          *"Rust"*)
              echo "cargo test && cargo clippy -- -D warnings && cargo fmt -- --check"
              ;;
      esac
  }

  步骤 4：添加 Rust 项目结构
  - 位置：plan-template.md 第 59-92 行
  - 添加 Option 4：
  # [REMOVE IF UNUSED] Option 4: Rust binary/library
  src/
  ├── main.rs or lib.rs
  ├── cli/          # CLI-specific (if binary)
  ├── core/         # Business logic
  └── utils/        # Utilities

  tests/
  ├── integration/
  └── common/       # Test utilities

  benches/          # Performance benchmarks (optional)

  步骤 5：添加 Rust 代码风格指导
  - 位置：agent-file-template.md
  - 修改 get_language_conventions()（update-agent-context.sh 第 265-268 行）：
  get_language_conventions() {
      local lang="$1"
      case "$lang" in
          *"Rust"*)
              echo "Rust: Follow Rust API Guidelines, use clippy, format with rustfmt, prefer Result over panic"
              ;;
          # 其他语言...
      esac
  }

  步骤 6：添加 Rust 忽略模式
  - 位置：.claude/commands/speckit.implement.md 第 87 行
  - 添加到模式库：
  - **Rust**: `target/`, `debug/`, `release/`, `*.rs.bk`, `*.rlib`, `*.prof*`, `.idea/`, `*.log`, `.env*`, `Cargo.lock` (if
  library)

  4.3.3 添加 Python FastAPI 技术栈支持示例

  步骤 1：扩展 plan-template.md
  **Python FastAPI-Specific**:
  - **Python Version**: [e.g., 3.11+ or NEEDS CLARIFICATION]
  - **ASGI Server**: [e.g., uvicorn, hypercorn or NEEDS CLARIFICATION]
  - **ORM**: [e.g., SQLAlchemy, Tortoise-ORM, or N/A]
  - **Migration Tool**: [e.g., Alembic, or N/A]

  步骤 2：添加 Python/FastAPI 项目结构
  # Option 5: Python FastAPI application
  app/
  ├── main.py
  ├── api/
  │   ├── routes/
  │   ├── dependencies.py
  │   └── models/
  ├── core/
  │   ├── config.py
  │   └── security.py
  ├── db/
  │   ├── base.py
  │   └── session.py
  └── schemas/

  tests/
  ├── api/
  ├── integration/
  └── conftest.py

  alembic/              # Database migrations
  requirements.txt or pyproject.toml

  步骤 3：添加 Python 命令
  get_commands_for_language() {
      case "$lang" in
          *"Python"*"FastAPI"*)
              echo "pytest --cov=app tests/ && ruff check . && mypy app/"
              ;;
          *"Python"*)
              echo "cd src && pytest && ruff check ."
              ;;
      esac
  }

  4.3.4 验证技术栈支持

  测试 Rust 支持：
  /speckit.specify "Build a CLI tool for parsing log files"
  /speckit.plan "Use Rust 2021 edition with tokio async runtime"

  # 检查 plan.md 包含 Rust 特定字段
  grep "Edition" specs/007-log-parser/plan.md

  # 检查 CLAUDE.md 更新
  grep "Rust" CLAUDE.md
  grep "cargo test" CLAUDE.md

  测试 FastAPI 支持：
  /speckit.specify "Build a REST API for task management"
  /speckit.plan "Use Python 3.11+ with FastAPI and SQLAlchemy"

  # 检查项目结构
  grep "app/api/routes/" specs/008-task-api/plan.md

  # 检查命令
  grep "pytest --cov" CLAUDE.md

  ---
  章节 4.4：场景 D - 自定义验证规则和质量门

  4.4.1 需求场景
  项目可能有特定的质量要求：
  - 强制代码覆盖率阈值
  - 强制 API 文档完整性
  - 强制可访问性标准
  - 强制性能基准

  4.4.2 在 Constitution 中定义质量门

  步骤 1：添加新原则
  - 文件：.specify/memory/constitution.md
  - 插入到 Core Principles 部分（第 22 行后）：
  ### V. Documentation Standards

  All public APIs and components MUST be documented with sufficient detail for external use.

  - **API Documentation**: All public endpoints MUST have OpenAPI/Swagger documentation including examples, error codes, and
  authentication requirements.
  - **Component Documentation**: All reusable components MUST have usage examples, prop/parameter descriptions, and
  accessibility notes.
  - **Code Comments**: Public functions MUST have docstrings explaining purpose, parameters, return values, and exceptions.
  - **README Completeness**: README MUST include setup instructions, usage examples, and contribution guidelines.

  **Rationale**: Comprehensive documentation reduces onboarding time, prevents misuse, and serves as a contract for API
  consumers.

  步骤 2：更新质量门
  - 位置：constitution.md 第 71-77 行
  - 添加文档检查：
  ## Quality Gates

  ...existing gates...

  - **Pre-Release**:
    ...existing checks...
    - Documentation completeness check MUST pass (all public APIs documented)
    - README validation MUST pass (setup and usage sections present)

  步骤 3：递增 Constitution 版本
  - 修改版本号（第 98 行）：
  **Version**: 1.1.0  # MINOR bump (new principle added)
  **Last Amended**: 2026-01-19

  4.4.3 在 Plan 命令中应用质量门

  自动应用：
  - AI 读取 constitution.md 时会自动看到新原则
  - 在生成 plan.md 的 Constitution Check 部分时会包含文档要求

  手动强化（可选）：
  - 文件：.claude/commands/speckit.plan.md
  - 插入到第 34 行后：
  3a. **Documentation Gate Check**:
      - Review Technical Context and features
      - Determine if public APIs are involved
      - If yes: Add to Constitution Check:
        - "Documentation Standards: Public API documentation required (OpenAPI/Swagger)"
        - "README must include API usage examples"

  4.4.4 在 Tasks 命令中生成文档任务

  修改位置：
  - 文件：.claude/commands/speckit.tasks.md
  - 插入到第 40 行（生成任务流程）后：
  3c. **Documentation Task Generation**:
      - Read constitution.md → Documentation Standards principle
      - If principle exists and project has public APIs:
        - Add documentation tasks to Final Phase (Polish)
        - Tasks:
          - Generate OpenAPI spec from contracts/
          - Write API usage examples in README
          - Add inline code documentation (docstrings)

  步骤 2：更新 tasks-template.md
  - 位置：第 153-158 行 Final Phase
  - 添加文档任务示例：
  ## Phase N: Polish & Cross-Cutting Concerns

  - [ ] TXXX [P] Generate OpenAPI documentation from contracts/ in docs/api.yaml
  - [ ] TXXX Write API usage examples in README.md
  - [ ] TXXX Add docstrings to all public functions
  - [ ] TXXX [P] Documentation updates in docs/
  - [ ] TXXX Code cleanup and refactoring
  ...

  4.4.5 在 Implement 命令中验证文档

  修改位置：
  - 文件：.claude/commands/speckit.implement.md
  - 插入到第 131 行（完成验证）：
  9. **Documentation Validation** (if Documentation Standards in constitution):
     - Check contracts/ has corresponding OpenAPI/Swagger specs
     - Check README includes setup and usage sections
     - Check public functions have docstrings
     - Report missing documentation as warnings (not blocking errors)

  4.4.6 添加代码覆盖率门槛示例

  步骤 1：在 Constitution 添加测试覆盖率要求
  ### II. Testing Standards (修改现有章节)

  ...existing content...

  - **Coverage Requirements**:
    - Critical paths MUST have 90%+ code coverage
    - Overall codebase MUST maintain 70%+ code coverage
    - New features MUST NOT decrease overall coverage

  步骤 2：在 Implement 命令中验证覆盖率
  9. Completion validation:
     - Verify all required tasks are completed
     - Check that implemented features match the original specification
     - **Run coverage report and verify thresholds**:
       - Extract coverage % from test output
       - Compare against constitution requirements (70% overall, 90% critical paths)
       - If below threshold: ERROR with report, do not mark implementation complete
     - Validate that tests pass and coverage meets requirements
     ...

  步骤 3：在 tasks 模板中添加覆盖率任务
  Final Phase: Polish
  ...
  - [ ] TXXX Generate code coverage report
  - [ ] TXXX Verify coverage meets 70% threshold per constitution
  - [ ] TXXX Add tests for uncovered critical paths (if < 90%)

  4.4.7 验证自定义质量门

  测试文档质量门：
  # 1. 更新 constitution
  /speckit.constitution "Add Documentation Standards principle requiring all public APIs to be documented"

  # 2. 创建 API 项目
  /speckit.specify "Build a public REST API for weather data"
  /speckit.plan "Use Node.js with Express"

  # 3. 检查 plan.md 的 Constitution Check
  grep "Documentation Standards" specs/009-weather-api/plan.md
  # 应包含文档要求

  # 4. 生成任务
  /speckit.tasks

  # 5. 检查是否有文档任务
  grep -i "documentation\|openapi\|swagger" specs/009-weather-api/tasks.md
  # 应存在文档生成任务

  测试覆盖率门槛：
  /speckit.implement

  # 实施过程中，测试覆盖率会被验证
  # 如果 < 70%，应看到错误：
  # ERROR: Code coverage (65%) below constitution requirement (70%)

  ---
  第五部分：快速参考和索引（约 1500 字）

  章节 5.1：文件路径快速索引

  5.1.1 按需求类型索引

  需求：修改命令行为
  ┌────────────────────────────────┬──────────────────────────────────────────┬──────────┐
  │            修改内容            │                 文件路径                 │ 行号参考 │
  ├────────────────────────────────┼──────────────────────────────────────────┼──────────┤
  │ 修改 specify 命令执行流程      │ .claude/commands/speckit.specify.md      │ 23-193   │
  ├────────────────────────────────┼──────────────────────────────────────────┼──────────┤
  │ 修改 plan 命令执行流程         │ .claude/commands/speckit.plan.md         │ 23-90    │
  ├────────────────────────────────┼──────────────────────────────────────────┼──────────┤
  │ 修改 tasks 命令执行流程        │ .claude/commands/speckit.tasks.md        │ 23-138   │
  ├────────────────────────────────┼──────────────────────────────────────────┼──────────┤
  │ 修改 implement 命令执行流程    │ .claude/commands/speckit.implement.md    │ 15-136   │
  ├────────────────────────────────┼──────────────────────────────────────────┼──────────┤
  │ 修改 constitution 命令执行流程 │ .claude/commands/speckit.constitution.md │ 18-83    │
  └────────────────────────────────┴──────────────────────────────────────────┴──────────┘
  需求：修改模板内容
  修改内容: 修改规格说明结构
  文件路径: .specify/templates/spec-template.md
  关键章节: User Stories (23-66), Requirements (78-101), Success Criteria (103-115)
  ────────────────────────────────────────
  修改内容: 修改实施计划结构
  文件路径: .specify/templates/plan-template.md
  关键章节: Technical Context (12-28), Project Structure (38-92)
  ────────────────────────────────────────
  修改内容: 修改任务列表结构
  文件路径: .specify/templates/tasks-template.md
  关键章节: Phase 结构 (47-158), 依赖关系 (163-195)
  ────────────────────────────────────────
  修改内容: 修改代理上下文模板
  文件路径: .specify/templates/agent-file-template.md
  关键章节: 全文 (1-29)
  ────────────────────────────────────────
  修改内容: 修改项目宪法
  文件路径: .specify/memory/constitution.md
  关键章节: Core Principles (22-70), Quality Gates (71-77)
  需求：修改脚本逻辑
  修改内容: 修改分支名生成规则
  文件路径: .specify/scripts/bash/create-new-feature.sh
  函数/行号: generate_branch_name() (180-226)
  ────────────────────────────────────────
  修改内容: 修改前置条件检查
  文件路径: .specify/scripts/bash/check-prerequisites.sh
  函数/行号: validate 逻辑 (102-120)
  ────────────────────────────────────────
  修改内容: 修改代理上下文更新
  文件路径: .specify/scripts/bash/update-agent-context.sh
  函数/行号: parse_plan_data() (168-206), update_existing_agent_file() (363-502)
  ────────────────────────────────────────
  修改内容: 修改通用函数库
  文件路径: .specify/scripts/bash/common.sh
  函数/行号: 各个函数 (4-157)
  5.1.2 按文件类型索引

  命令定义文件（.claude/commands/）：
  speckit.constitution.md    - 项目宪法管理 (83 行)
  speckit.specify.md          - 功能规格创建 (259 行)
  speckit.plan.md             - 实施计划生成 (90 行)
  speckit.tasks.md            - 任务分解生成 (138 行)
  speckit.implement.md        - 代码实施执行 (136 行)
  speckit.clarify.md          - 规格澄清（未详述）
  speckit.analyze.md          - 一致性分析（未详述）
  speckit.checklist.md        - 清单生成（未详述）
  speckit.taskstoissues.md    - 任务转 GitHub Issues（未详述）

  模板文件（.specify/templates/）：
  spec-template.md            - 功能规格模板 (116 行)
  plan-template.md            - 实施计划模板 (105 行)
  tasks-template.md           - 任务列表模板 (252 行)
  agent-file-template.md      - 代理上下文模板 (29 行)
  checklist-template.md       - 清单模板（未详述）

  脚本文件（.specify/scripts/bash/）：
  common.sh                   - 通用函数库 (157 行)
  create-new-feature.sh       - 创建新特性 (298 行)
  setup-plan.sh               - 设置计划文件 (62 行)
  check-prerequisites.sh      - 检查前置条件 (167 行)
  update-agent-context.sh     - 更新代理上下文 (800 行)

  内存文件（.specify/memory/）：
  constitution.md             - 项目宪法 (99 行)

  输出目录（specs/###-short-name/）：
  spec.md                     - 功能规格说明
  plan.md                     - 技术实施计划
  research.md                 - 技术研究（可选）
  data-model.md               - 数据模型（可选）
  quickstart.md               - 快速入门（可选）
  tasks.md                    - 任务清单
  contracts/                  - API 合约（可选）
  checklists/                 - 质量清单（可选）

  5.1.3 按命令索引文件依赖

  /speckit.constitution
  - 读取：.specify/memory/constitution.md
  - 写入：.specify/memory/constitution.md
  - 验证：plan-template.md, spec-template.md, tasks-template.md

  /speckit.specify
  - 脚本：create-new-feature.sh
  - 模板：spec-template.md
  - 写入：specs/###-name/spec.md, specs/###-name/checklists/requirements.md

  /speckit.plan
  - 脚本：setup-plan.sh, update-agent-context.sh
  - 模板：plan-template.md, agent-file-template.md
  - 读取：specs/###-name/spec.md, .specify/memory/constitution.md
  - 写入：specs/###-name/plan.md, research.md, data-model.md, contracts/, quickstart.md, CLAUDE.md

  /speckit.tasks
  - 脚本：check-prerequisites.sh
  - 模板：tasks-template.md
  - 读取：plan.md, spec.md, data-model.md(可选), contracts/(可选), research.md(可选)
  - 写入：specs/###-name/tasks.md

  /speckit.implement
  - 脚本：check-prerequisites.sh
  - 读取：tasks.md, plan.md, checklists/(可选), 所有设计文档
  - 写入：项目代码文件, 更新的 tasks.md（标记完成）, 忽略文件

  ---
  章节 5.2：占位符完整清单

  5.2.1 通用占位符
  - [FEATURE NAME] - 功能名称
  - [###-feature-name] - 分支名格式（### 为三位数字）
  - [DATE] - 日期（YYYY-MM-DD）
  - $ARGUMENTS - 用户输入的原始参数

  5.2.2 规格说明占位符（spec-template.md）
  - [Brief Title] - 用户故事标题
  - [Describe this user...] - 故事描述
  - [Why this priority] - 优先级理由
  - [Independent Test] - 独立测试说明
  - [initial state], [action], [expected outcome] - Given-When-Then 场景
  - [boundary condition], [error scenario] - 边界和错误情况
  - [specific capability] - 功能需求
  - [Entity 1/2] - 实体名称
  - [Measurable metric] - 成功标准
  - [NEEDS CLARIFICATION: question] - 待澄清问题（最多 3 个）

  5.2.3 实施计划占位符（plan-template.md）
  - [FEATURE] - 功能名称
  - [link] - spec.md 相对路径
  - [Extract from feature spec] - 摘要
  - Technical Context 字段：
    - [e.g., Python 3.11... or NEEDS CLARIFICATION] - 9 个技术字段
  - [Gates determined based on constitution] - 质量门
  - [REMOVE IF UNUSED] Option 1/2/3 - 项目结构选项

  5.2.4 任务列表占位符（tasks-template.md）
  - [Title] - 用户故事标题
  - [Brief description] - 故事目标
  - [How to verify] - 独立测试方法
  - [language], [framework] - 技术栈
  - [endpoint], [Entity1/2], [Service] - 组件名称
  - [name], [location] - 文件名和路径

  5.2.5 代理上下文占位符（agent-file-template.md）
  - [PROJECT NAME] - 项目名
  - [EXTRACTED FROM ALL PLAN.MD FILES] - 技术栈列表
  - [ACTUAL STRUCTURE FROM PLANS] - 项目结构
  - [ONLY COMMANDS FOR ACTIVE TECHNOLOGIES] - 命令
  - [LANGUAGE-SPECIFIC...] - 代码风格
  - [LAST 3 FEATURES...] - 最近变更

  5.2.6 宪法占位符（constitution.md）
  - [PROJECT_NAME] - 项目名
  - [CONSTITUTION_VERSION] - 版本号
  - [RATIFICATION_DATE] - 首次通过日期
  - [LAST_AMENDED_DATE] - 最后修订日期
  - [PRINCIPLE_N_NAME] - 原则名称（N 可变）

  ---
  章节 5.3：常用操作速查

  5.3.1 创建新特性完整流程
  # 1. 定义项目原则（可选，初次项目时）
  /speckit.constitution "Focus on code quality, testing, UX consistency, and performance"

  # 2. 创建功能规格
  /speckit.specify "Add user authentication with email and password"

  # 3. 生成技术计划
  /speckit.plan "Use Node.js with Express and PostgreSQL"

  # 4. 分解任务
  /speckit.tasks

  # 5. 执行实施
  /speckit.implement

  5.3.2 诊断问题
  # 检查当前分支
  git rev-parse --abbrev-ref HEAD

  # 检查特性目录
  ls -la specs/

  # 检查前置条件
  .specify/scripts/bash/check-prerequisites.sh

  # 查找未解决的 NEEDS CLARIFICATION
  grep -r "NEEDS CLARIFICATION" specs/003-user-auth/

  # 检查占位符是否已替换
  grep -E '\[.*\]' specs/003-user-auth/spec.md | grep -v '^\s*-'

  # 手动运行脚本查看详细输出
  .specify/scripts/bash/create-new-feature.sh --json "Test feature"

  5.3.3 修改现有特性
  # 切换到特性分支
  git checkout 003-user-auth

  # 修改规格
  vim specs/003-user-auth/spec.md

  # 重新生成计划
  /speckit.plan "Updated: Add OAuth2 support"

  # 重新生成任务
  /speckit.tasks

  # 继续实施
  /speckit.implement

  5.3.4 自定义模板
  # 1. 复制现有模板
  cp .specify/templates/spec-template.md .specify/templates/spec-template-custom.md

  # 2. 编辑自定义模板
  vim .specify/templates/spec-template-custom.md

  # 3. 修改命令逻辑以使用自定义模板
  vim .claude/commands/speckit.specify.md
  # 在第 100 行附近添加模板选择逻辑

  5.3.5 添加新技术栈支持
  # 1. 编辑计划模板添加技术特定字段
  vim .specify/templates/plan
  ⎿  API Error: Claude's response exceeded the 32000 output token maximum. To configure this behavior, set the
     CLAUDE_CODE_MAX_OUTPUT_TOKENS environment variable.

● [MODE: PLAN]

  继续完成计划的剩余部分。

  ---
  5.3.5 添加新技术栈支持（续）
  # 1. 编辑计划模板添加技术特定字段
  vim .specify/templates/plan-template.md
  # 在 Technical Context 部分添加新字段

  # 2. 编辑 update-agent-context.sh 添加字段提取
  vim .specify/scripts/bash/update-agent-context.sh
  # 在 parse_plan_data() 函数添加新字段提取
  # 在 get_commands_for_language() 添加新语言的命令

  # 3. 添加忽略文件模式
  vim .claude/commands/speckit.implement.md
  # 在第 77-99 行的模式库添加新技术栈模式

  # 4. 测试新技术栈
  /speckit.specify "Build a test project"
  /speckit.plan "Use <your new tech stack>"
  # 验证 plan.md 和 CLAUDE.md 正确更新

  5.3.6 批量更新多个特性的代理上下文
  # 更新所有现有特性的代理上下文
  for feature in specs/*/plan.md; do
      feature_dir=$(dirname "$feature")
      cd "$feature_dir"
      ../../.specify/scripts/bash/update-agent-context.sh claude
      cd ../..
  done

  ---
  章节 5.4：错误信息速查表
  ┌───────────────────────────────────┬──────────────────────┬────────────────────────────┬─────────────────────────────┐
  │             错误信息              │         命令         │            原因            │          解决方法           │
  ├───────────────────────────────────┼──────────────────────┼────────────────────────────┼─────────────────────────────┤
  │ "Not on a feature branch"         │ All                  │ 分支名不符合 ###-name 格式 │ 运行 /speckit.specify       │
  ├───────────────────────────────────┼──────────────────────┼────────────────────────────┼─────────────────────────────┤
  │ "No feature description provided" │ specify              │ 未提供参数                 │ 添加特性描述参数            │
  ├───────────────────────────────────┼──────────────────────┼────────────────────────────┼─────────────────────────────┤
  │ "Cannot determine user scenarios" │ specify              │ 描述太模糊                 │ 提供更详细描述              │
  ├───────────────────────────────────┼──────────────────────┼────────────────────────────┼─────────────────────────────┤
  │ "plan.md not found"               │ plan/tasks/implement │ 未运行 plan                │ 运行 /speckit.plan          │
  ├───────────────────────────────────┼──────────────────────┼────────────────────────────┼─────────────────────────────┤
  │ "tasks.md not found"              │ implement            │ 未运行 tasks               │ 运行 /speckit.tasks         │
  ├───────────────────────────────────┼──────────────────────┼────────────────────────────┼─────────────────────────────┤
  │ "ERROR if violations unjustified" │ plan                 │ Constitution Check 失败    │ 填写 Complexity Tracking 表 │
  ├───────────────────────────────────┼──────────────────────┼────────────────────────────┼─────────────────────────────┤
  │ "Template not found"              │ plan                 │ 模板文件缺失               │ 检查 .specify/templates/    │
  ├───────────────────────────────────┼──────────────────────┼────────────────────────────┼─────────────────────────────┤
  │ "Branch name exceeded 244 bytes"  │ specify              │ 分支名太长                 │ 使用 --short-name 缩短      │
  ├───────────────────────────────────┼──────────────────────┼────────────────────────────┼─────────────────────────────┤
  │ "Checklist incomplete"            │ implement            │ 清单未完成                 │ 完成清单或选择继续          │
  └───────────────────────────────────┴──────────────────────┴────────────────────────────┴─────────────────────────────┘
  ---
  章节 5.5：工作流程决策树

  开始新特性
      ↓
  是否是首次使用项目？
      ├─ 是 → 运行 /speckit.constitution
      └─ 否 → 跳过
      ↓
  运行 /speckit.specify <description>
      ↓
  规格是否有 NEEDS CLARIFICATION？
      ├─ 是 → 回答问题 → AI 更新 spec.md
      └─ 否 → 继续
      ↓
  运行 /speckit.plan <tech constraints>
      ↓
  计划是否有 NEEDS CLARIFICATION？
      ├─ 是 → AI 生成 research.md → 解决后更新 plan.md
      └─ 否 → 继续
      ↓
  Constitution Check 是否通过？
      ├─ 否 → 填写违规说明或修改设计
      └─ 是 → 继续
      ↓
  运行 /speckit.tasks
      ↓
  任务列表是否满意？
      ├─ 否 → 手动调整 tasks.md 或修改 plan.md 重新生成
      └─ 是 → 继续
      ↓
  运行 /speckit.implement
      ↓
  是否有清单文件？
      ├─ 是 → 验证清单 → 未完成？→ 选择继续或停止
      └─ 否 → 跳过
      ↓
  逐阶段执行任务
      ↓
  每个阶段成功？
      ├─ 否 → 修复错误 → 重新运行 /speckit.implement
      └─ 是 → 继续下一阶段
      ↓
  所有任务完成
      ↓
  运行测试和验证
      ↓
  完成 ✓

  ---
  实施清单

  基于以上计划，以下是为 AI 自身制定的工作步骤清单。每项任务相互独立，按顺序执行。

  注意：本清单将保存到时间戳文件 dialogs/spec-kit-workflow-guide-plan-2026-01-19--08-15.md（当前时间为示例）。

  实施清单

  1. 创建主文档文件 spec-kit-workflow-explanation.md 在项目根目录
  2. 编写第一部分：概览与导航（1.1 文档说明、1.2 框架全景图、1.3 五命令速览表）
  3. 编写章节 2.1：/speckit.constitution 命令详解（概述、流程图、文件清单、占位符、验证机制、修改点、错误处理）
  4. 编写章节 2.2：/speckit.specify 命令详解（概述、流程图、文件清单、占位符、脚本机制、验证机制、修改点、错误处理）
  5. 编写章节 2.3：/speckit.plan 命令详解（概述、流程图、文件清单、占位符、脚本机制、Constitution Check、Phase
  0/1、修改点、错误处理）
  6. 编写章节 2.4：/speckit.tasks 命令详解（概述、流程图、文件清单、脚本机制、任务生成规则、依赖关系、修改点、错误处理）
  7. 编写章节 2.5：/speckit.implement
  命令详解（概述、流程图、文件清单、清单验证、忽略文件管理、任务执行、进度跟踪、修改点、错误处理）
  8. 编写章节 3.1：脚本基础设施层（common.sh 功能、脚本调用时序、错误传播机制）
  9. 编写章节 3.2：占位符替换规则完整指南（类型分类、各模板占位符索引、自定义占位符流程、验证机制）
  10. 编写章节 3.3：验证机制和错误处理策略（三层架构、验证清单汇总、错误诊断步骤、常见错误速查表、自定义验证规则方法）
  11. 编写章节 4.1：场景 A - 调整任务拆分粒度（需求场景、当前粒度、细粒度调整、粗粒度调整、验证方法）
  12. 编写章节 4.2：场景 B - 适配不同项目类型（需求场景、前端模板创建、后端模板优化、CLI 模板创建、验证方法）
  13. 编写章节 4.3：场景 C - 为特定技术栈添加详细指导（需求场景、Rust 支持示例、FastAPI 支持示例、验证方法）
  14. 编写章节 4.4：场景 D - 自定义验证规则和质量门（需求场景、Constitution 定义、Plan/Tasks/Implement 应用、验证方法）
  15. 编写章节 5.1：文件路径快速索引（按需求类型索引、按文件类型索引、按命令索引依赖）
  16. 编写章节 5.2：占位符完整清单（通用、规格说明、实施计划、任务列表、代理上下文、宪法）
  17. 编写章节 5.3：常用操作速查（创建特性流程、诊断问题、修改特性、自定义模板、添加技术栈、批量更新）
  18. 编写章节 5.4：错误信息速查表（错误信息、命令、原因、解决方法的对照表）
  19. 编写章节 5.5：工作流程决策树（文本或 Mermaid 格式的决策流程）
  20. 在文档中插入 Mermaid 流程图（章节 2.1-2.5 的执行流程图）
  21. 审查文档完整性（检查所有章节是否完成、链接是否正确、格式是否一致）
  22. 创建快速参考文件 spec-kit-quick-reference.md（提取第五部分内容为独立文档）
  23. 在主文档顶部添加目录（自动生成或手动编写，链接到各章节）
  24. 在主文档末尾添加附录（术语表、参考资料、更新日志）
  25. 进行最终格式化和排版（确保 Markdown 渲染正确、代码块语法高亮、表格对齐）

  ---
  审查部分

  完成后的审查步骤：

  1. 内容完整性审查
    - 检查所有 5 个命令是否都有详细解释
    - 验证每个命令的 8 个子部分都已完成（概述、流程图、文件清单、占位符、机制详解、修改点、错误处理）
    - 确认 4 个场景调整指南都已编写
  2. 技术准确性审查
    - 对照实际文件验证所有引用的行号和文件路径
    - 验证所有脚本命令和函数名的正确性
    - 检查所有占位符列表的完整性
  3. 可用性审查
    - 确保文档能回答用户的三个核心问题：
        i. 命令如何触发脚本和模板？✓
      ii. 信息如何在命令间传递？✓
      iii. 修改时如何定位影响范围？✓
    - 验证快速索引表的实用性
    - 测试决策树的逻辑完整性
  4. 格式规范审查
    - Markdown 语法正确
    - 代码块使用正确的语言标识
    - 表格格式对齐
    - Mermaid 图表语法正确

  ---
  下一步：

  1. 输入 ENTER EXECUTE MODE 进入下一模式
  2. 如不满意计划，可复制粘贴：请重新执行 PLAN MODE。
```